故事背景
===
小弟目前在開發一個**會議管理系統**。

內容大致上就是一個**行事曆列表**。

![](https://raw.githubusercontent.com/neverlostmine/RecurrenceRuleQuestion/master/pics/p1.png)

於日期上可以建立會議。

會議分為**一般會議**(單日)跟**循環會議**(可能用於例會 例如 每周 每月)。

另外還分**內部會議**及**外部會議**。

如果是內部會議，會一同進行**會議室預約**，這時需要判斷會議室是否可以預約。

與會人員如果是內部員工(於系統上有帳號)，則需要顯示使用者是否該時段無其他會議。

![](https://raw.githubusercontent.com/neverlostmine/RecurrenceRuleQuestion/master/pics/p2.png)

專案架構
===
採用 MEAN (MongoDB、Express、AngularJS 2、Node.js)

解析 RRule 的套件為 [jkbrzt / rrule](https://github.com/jkbrzt/rrule)

套件包含 .all() .between() .before() .after() 方法

iCalendar
===
谷歌了一下不難發現，行事曆通常使用 iCalendar standard。

[wikipedia](https://zh.wikipedia.org/zh-hant/ICalendar)

[https://icalendar.org/](https://icalendar.org/)

發邀請時信裡附加的 ICS 檔 就是使用這個格式。

其中紀錄循環規則的部分為 RRule (Recurrence Rule)。

[https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html](https://icalendar.org/iCalendar-RFC-5545/3-8-5-3-recurrence-rule.html)

[https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html)

有限循環 :

每兩週之週日，起始於2017年01月01日，重複 3 次

> RRule : FREQ=WEEKLY;DTSTART=20170101T000000Z;BYDAY=SU;INTERVAL=2;COUNT=3

無限循環 :

每周一次，起始於2017年01月01日

> RRule : FREQ=DAILY;DTSTART=20170101T000000Z;INTERVAL=1

google calendar、iCloud Calendar、outlook行事曆 等大廠也都允許建立循環事件。

難題一 : 循環事件如何設計DB?
===
> 目前我只想到這兩種模式，但是我都覺得不太好。

方法一 : 紀錄 Recurrence Rule，需要比對時先算出所有落點時間再加以判斷
---
優點 : 每個循環事件只有一筆資料，DB使用空間極少。

缺點 : 即時運算耗時。

方法二 : 紀錄所有的落點時間，需要比對時直接下查詢語法比對
---
優點 : 查詢相對快速，但是如果循環事件。

缺點 : 每個循環事件紀錄所有的落點時間，DB使用空間極大，此外無限循環事件也無法紀錄所有落點時間。

> 如果是每日循環事件。
>
> 紀錄10年，一筆約96.6K，取得所有落點的運算小於1秒。
>
> 紀錄100年，一筆約963K，取得所有落點的運算約2秒。
>
> 紀錄1000年，一筆約9.4MB，取得所有落點的運算約8秒。
>
> 紀錄到西元9999年，當機了無回應，但是大概可以推算需要約 94MB。
>
> 目前我採用方法一，但是如預料中**運算的效能不甚理想**，並且還有其他功能無法達成。

難題二 : 時間重疊比對
===
不論是判斷**會議室是否空閒**或者**使用者是否空閒**都是要做時間重疊的比對。

**固定日期**比對**固定日期** :
---
一般固定日期的事件最簡單，直接做**起始時間**和**結束時間**的比對即可得知是否重疊。

例如 **2017年01月01日 09點** 至 **2017年01月01日 10:00** 時段有會議。

> **2017-01-01T09:00:00.000z** ~ **2017-01-01T10:00:00.000z**

則未重疊範圍為 :

**結束時間** 小於 **2017-01-01 09:00** 及 **開始時間** 大於 **2017-01-01 10:00**。

>  (**start** ~ **end**) < **2017-01-01T09:00:00.000z** ~ **2017-01-01T10:00:00.000z** < (**start** ~ **end**)

**固定日期**比對**循環日期** :
---
與循環日期比對則麻煩許多。

如果採用方法一設計的DB :

則需要先算出所有的循環活動於比對時間範圍附近的落點，再比對是否重疊。

如果採用方法二設計的DB :

則把比對時間當成查詢條件，直接搜所有落點是否重疊。

**循環日期** 比對 **循環日期** :
---
如果是有限循環的話，還是可以硬幹全部算出來比對(但是要花多久比對完就是另一回事了)。

但是如果是無限循環的話，目前我還沒想出來該怎麼弄。

難題三 : 循環例外
===
循環事件是可以修改的，如果曾使用過 google calendar，就會看過這個畫面。

![](https://raw.githubusercontent.com/neverlostmine/RecurrenceRuleQuestion/master/pics/p3.png)

修改循環事件之後，會詢問作用範圍，分別為**僅限此次活動**、**後續活動**及**所有活動**。

谷歌一下不難發現，iCalendar 使用 EXDATE 來記錄例外。

紀錄 RRule 跟 EXDATE 都不是難事，難的地方還是在日期的判斷，尤其是重疊判斷，

再加上循環事件中還有例外日期，小弟實在想不出 DB 該怎麼設計較佳。

嘗試過的解法
===

使用線性函數
---
如果是有固定頻率，循環事件其實是一個線性函數。

> 由於**頻率**是整數，所以實際上的圖形應該是 - - - 線

落點 = 開始時間 + X 倍的頻率。

> y = start + ( x * Freq )

函數十分有用，可以直接帶入某個日期 y ，如果 x 是整數，表示該日期會重疊。

> 甚至可以使用**斜率**來判斷對**兩組循環事件**是否會重疊

**每日** **每周**，都是固定頻率，可以這樣運算。

但是 **每月** **每年** 並不是固定頻率，月有 30、31、28、29 天的分別 年也有 365 跟 366。

小弟數學不是太好，實在想不出 **每月** 跟 **每年** 的函數要怎麼寫，所以使用函數的解法沒有成功。

他人的建議
===
放棄所謂的 無限循環事件 及 無限日曆。
---
> 人固有一死，或重於泰山，或輕於鴻毛

理論上不太可能也沒有必要建立無限循環的會議，即使員工都不離職退休，也總會死<del>(其實你的系統可能更早說掰掰)</del>。

所以可以設定值域範圍 1 年、5 年、10 年、20 年 或者 100 年。

一來可以避開無限循環的比對(如果要硬幹比對的話)，

二來可以防止不合理的日期輸入(例如預約西元3000年的會議)。

但是另一個問題是，值域範圍要如何界定才算最佳？
